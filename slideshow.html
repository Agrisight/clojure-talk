<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <style type="text/css">
      @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Hacking In Clojure

---

# Brief Intro to Clojure/Lisp

* Normally, you call functions this way

```python
foo(1, 3, 4)
```
* Now, move that leftmost parenthesis a little _more_ to the left:

```clojure
(foo 1 2 3) ; that wasn't so hard!
```
* Anything of that form is called an "s-expression":

```clojure
(whatever-you-are-doing arg1 arg2 ...) ; those dots are not valid clojure
```
In lisps, *everything* is an s-expression...

(continued on next slide)
---
# S-Expression Examples
* Defining things

```clojure
(def message "Hello World")

(defn add-two-things 
  "Obligatory useless addition example"
  [x y]
  (+ x y))
```

* Control statements

```clojure
(if (predicate? item) 
  (do-something item) 
  (do-something-else item))

(while true 
  (do-something-endlessly))
```
That's it!
---
# How to Server in Clojure: Ring
* From the [Github Page](https://github.com/ring-clojure/ring)
> Ring is a Clojure web applications library inspired by Python's WSGI
  and Ruby's Rack

* A Ring application is just a clojure function:

```clojure
(defn app [request]
  {:status 200
   :headers {"Content-Type" "text/html"}
   :body "Hello World"})
```
* To actually run the app, you plug the function into some magic java
server adapter which handles the actual requesting and responsing

* Very simple, and (as we'll soon see), *very* powerful
---
# First, "Higher Order Functions"
* Any function that takes another function as an argument and/or
returns a function

* The most well-known examples are the classic collection processing
functions: `map`, `filter`, `reduce` etc.

```clojure
(map inc [1 2 3]) ; => (2 3 4)

(filter pos? [-8 -2 1 9 3]) ; => (1 9 3)

(reduce + [1 2 3]) ; => 6
```
* function composition and partial application:

```clojure
(def filter-then-count (comp count filter))

(filter-then-count neg? [-3 -2 -1 1 2 3]) ; => 3

(def add-two (partial + 2))

(add-two 5) ; => 7

```
---
# Back to Ring: Middleware
Remember our simple  app?
```clojure
(defn app [request]
  {:status 200
   :headers {"Content-Type" "text/html"}
   :body "Hello World"})
```
"Hello World" is pretty sensitive info, so we should authenticate
every request:
```clojure
(defn get-cookie [name request] ...) ; not a valid clojure function

(defn wrap-authentication [handler]
  (fn [request]
    (let [session (get-cookie "session" request)]
      (if (= "superSecretSesssionId" session)
          (handler request)
          {:status 403 :body "You're not allowed!"}))))

(def secure-app (wrap-authentication app))
```
We can create an authenticated web app from our old web app using
higher-order functions!
---


    </textarea>
    <script src="http://gnab.github.io/remark/downloads/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create();
    </script>
  </body>
</html>
